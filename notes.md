# 前端知识查漏补缺


## 目录
**JavaScript篇**
1. [JS数据类型](#1)
2. [强制类型转换](#2)
3. [运算符](#3)
4. [变量、函数和对象](#4)
	- [变量及对象存储](#41)
	- [隐式全局变量](#42)
	- [预解析](#43)
	- [函数的定义](#44)
	- [声明提前](#45)
	- [匿名函数](#46)
	- [函数的调用](#47)
	- [作用域](#48)
	- [对象操作](#49)
	- [对象创建](#410)
	- [构造函数](#411)
	- [原型](#412)
	
5. [数组](#5)
6. [字符串](#5)
7. [正则表达式](#7)
8. [DOM](#8)


***
### <span id="1">JS数据类型</span>
- **数据类型指的就是字面量的类型，在JS中一共有六种数据类型**
	- String 字符串
	- Number 数值
	- Boolean 布尔值
	- Null 空值
	- Undefined 未定义
	- Object 对象
 
	其中String Number Boolean Null Undefined属于基本数据类型，而Object属于引用数据类型

- **在JS中所有的数值都是Number类型, 包括整数和浮点数（小数）**
	- JS中可以表示的数字的最值:
		- Number.MAX_VALUE
			- 1.7976931348623157e+308

		- Number.MIN_VALUE (大于0的最小值)
			- 5e-324

	- 如果使用Number表示的数字超过了最大值，则会返回:
		- Infinity 表示正无穷
		- -Infinity 表示负无穷
	- 使用typeof检查Infinity也会返回number
	- NaN 是一个特殊的数字，表示Not A Number
	- 使用typeof检查一个NaN也会返回number	

- **Null和undefined**
	- Null（空值）类型的值只有一个，就是null
		- null这个值专门用来表示一个为空的对象
		- 使用typeof检查一个null值时，会返回object
	- Undefined（未定义）类型的值只有一个，就undefind
		- 当声明一个变量，但是并不给变量赋值时，它的值就是undefined
		- 使用typeof检查一个undefined时也会返回undefined
		
***

### <span id="2">强制类型转换</span>
- **强制类型转换**
	- 指将一个数据类型强制转换为其他的数据类型
		- 类型转换主要指，将其他的数据类型，转换为
			- String Number Boolean
			
- **将其他的数据类型转换为String**
	1. 方式一：
		- 调用被转换数据类型的toString()方法
		- 该方法不会影响到原变量，它会将转换的结果返回
		- 但是注意：null和undefined这两个值没有toString()方法，如果调用他们的方法，会报错
	
		-	注意:
		 	-	无参数，转化为字符串
		 	-	如果有参数，就会将数值转化为对应参数的进制
		 		- 如 num.toString(2) 转化为2进制数字符串

	2. 方式二：
		- 调用String()函数，并将被转换的数据作为参数传递给函数
		- 使用String()函数做强制类型转换时，
			1. 对于Number和Boolean实际上就是调用的toString()方法
			2. 但是对于null和undefined，就不会调用toString()方法
				- 它会将 null 直接转换为 "null"
				- 将 undefined 直接转换为 "undefined"

- **将其他的数据类型转换为Number**
	1. 转换方式一：
		- 使用Number()函数
		- 字符串 --> 数字
			1. 如果是纯数字的字符串，则直接将其转换为数字
			2. 如果字符串中有非数字的内容，则转换为NaN
			3. 如果字符串是一个空串或者是一个全是空格的字符串，则转换为0
		- 布尔 --> 数字
			- true 转成 1
			- false 转成 0
			- null --> 数字     0
			- undefined --> 数字 NaN
 
	2. 转换方式二：
		- 这种方式专门用来对付字符串
		- parseInt() 把一个字符串转换为一个整数
		- parseFloat() 把一个字符串转换为一个浮点数
		
		- 如果对非String使用parseInt()或parseFloat()，它会先将其转换为String然后再提取出有效数字
	
	3. 在js中:
		- 如果需要表示16进制的数字，则需要以0x开头
		- 如果需要表示8进制的数字，则需要以0开头
		- 如果要要表示2进制的数字，则需要以0b开头
		- 但并不是所有的浏览器都支持

- **将其他的数据类型转换为Boolean**
	- 使用Boolean()函数
	- 数字 ---> 布尔
		- 除了0和NaN，其余的都是true
	 
	- 字符串 ---> 布尔
		- 除了空串，其余的都是true
	 
	- null和undefined都会转换为false
	 
	- 对象也会转换为true
	
***

### <span id="3">运算符</span>

- 运算符也叫操作符，通过运算符可以对一个或多个值进行运算,并获取运算结果
 	- 比如：typeof就是运算符，可以来获得一个值的类型
 	- 它会将该值的类型以字符串的形式返回
 	- number string boolean undefined object
 
- **算数运算符**
 	- 当对非Number类型的值进行运算时，会将这些值转换为Number然后再运算
 	- 任何值和NaN做运算都得NaN
	- +可以对两个值进行加法运算，并将结果返回
	- 如果对两个字符串进行加法运算，则会做拼串，会将两个字符串拼接为一个字符串，并返回
	- 任何的值和字符串做加法运算，都会先转换为字符串，然后再和字符串做拼串的操作
	- 因为精度丢失问题，**不要判断计算后的两个浮点数是否相等**, js中，小数计算，会出现精度丢失，比如0.1+0.2=0.300000000004
 
- **任何值和字符串相加都会转换为String，并做拼串操作**
	- 我们可以利用这一特点，来将一个任意的数据类型转换为String
	- 我们只需要为任意的数据类型 + "" 即可将其转换为String
	- 这是一种隐式的类型转换，由浏览器自动完成，实际上它也是调用String()函数
	
- **任何值做- * /运算时都会自动转换为Number**
	- 我们可以利用这一特点做隐式的类型转换
	- 可以通过为一个值 -0 *1 /1来将其转换为Number
	- 原理和Number()函数一样，使用起来更加简单
		
- **一元运算符，只需要一个操作数**
 	+ 正号
 		- 正号不会对数字产生任何影响
 	- 负号
 		- 负号可以对数字进行负号的取反
 
 	- 对于非Number类型的值，
 		它会将先转换为Number，然后再运算
 		可以对一个其他的数据类型使用+,来将其转换为number
 		它的原理和Number()函数一样

- **逻辑运算符**
	- JS中为我们提供了三种逻辑运算符
	- ! 非
	 	- !可以用来对一个值进行非运算
	 	- 所谓非运算就是值对一个布尔值进行取反操作，
	 		true变false，false变true
	 	- 如果对一个值进行两次取反，它不会变化
	 	- 如果对非布尔值进行运算，则会将其转换为布尔值，然后再取反,
	 		所以我们可以利用该特点，来将一个其他的数据类型转换为布尔值
	 		- 可以为一个任意数据类型取两次反，来将其转换为布尔值: !!x, 原理和Boolean()函数一样

	- && 与
	 	- &&可以对符号两侧的值进行与运算并返回结果
	 	- 运算规则
	 		- 两个值中只要有一个值为false就返回false，
	 			只有两个值都为true时，才会返回true
			- JS中的“与”属于[短路的与]，
	 			如果第一个值为false，则不会看第二个值

	- || 或
	 	- ||可以对符号两侧的值进行或运算并返回结果
	 	- 运算规则：
	 		- 两个值中只要有一个true，就返回true
	 			如果两个值都为false，才返回false
			- JS中的“或”属于[短路的或]
			如果第一个值为true，则不会检查第二个值

- **关系运算符**
	- 通过关系运算符可以比较两个值之间的大小关系，如果关系成立它会返回true，如果关系不成立则返回false
	- 非数值的情况
		- 对于非数值进行比较时，会将其转换为数字然后在比较
		- 如果符号两侧的值**都是字符串**时，不会将其转换为数字进行比较,而会分别比较字符串中字符的Unicode编码
	- 如果比较的两个字符串型的数字，可能会得到不可预期的结果!
		- 注意：在【比较两个字符串型的数字时，一定一定一定要转型】
			```console.log("11123123123123123123" < "5"); //true```
		- 转一个即可，只要不全是字符串，就可以自动转化为数字
			```console.log("11123123123123123123" < +"5"); //False```
		
- **相等运算符**
	- 相等和不相等：== !=
		- 如果一个操作数是布尔值，那么在比较相等性前先将其转换为数值
		- 如果一个操作数是字符串，另一个操作数是数值，比较相等性前先将字符串转换为数值
		- 如果一个操作数是对象，另一个操作数不是，则调用对象的valueOf()方法，用得到的基本类型按前面的规则进行比较
	
	- 注意：
		- null和undefined是相等的
		- 比较相等性之前，不能将null和undefined转换为其他任何值
		- 如果有一个操作数是NaN，则相等操作符返回false，即使两个操作数都是NaN，相等操作符也返回false
		- 如果两个操作数都是对象，则比较它们是不是指向同一个对象
		- 可以通过isNaN()函数来判断一个值是否是NaN, 如果该值是NaN则返回true，否则返回false
	
	- eg:
		- null == undefined //true
		- "NaN" == NaN //false
		- undefined == 0 //false     
		- null == 0 //false		
		- undefined == false //false     
		- null == false //false				

- **条件运算符**
	- 条件运算符也叫三元运算符
	- 语法：条件表达式?语句1:语句2;
	- 执行的流程：
		- 条件运算符在执行时，首先对条件表达式进行求值，如果该值为true，则执行语句1，并返回执行结果，如果该值为false，则执行语句2，并返回执行结果
		- 如果条件的表达式的求值结果是一个非布尔值，会将其转换为布尔值然后在运算
 		
	- 求3个数中的最大值:
	
	```
	function getMaxThree(a,b,c){
		var d = a>b?a:b;
		return d>c?d:c;
	}	
	```
	
***
<a name="4" />
<a name="1" />
<a name="2" />
### <span id="4">变量、函数和对象</span>

- <span id="41">**JS中的变量保存到栈内存中**</span>

	- 基本数据类型的值直接在**栈内存**中存储，值与值之间是独立存在，修改一个变量不会影响其他的变量

- **JS中的对象保存到堆内存中**
	- 每创建一个新的对象，就会在**堆内存**中开辟出一个新的空间，而变量保存的是对象的内存地址（对象的引用），如果两个变量保存的是同一个对象引用，当一个通过一个变量修改属性时，另一个也会受到影响

- **参数赋值的时候**: 
	- 简单数据类型传数值（栈中）而不是栈中的同一个地址，所以修改不了栈中的原数值
	- 复杂数据类型传地址（堆中）（修改的同一片内存空间）
	- 当修改成员变量中的简单数据类型时，不要通过参数传递，要在函数中直接修改


- <span id="42">**隐式全局变量**</span>
	- 在函数体内声明变量要注意
	
	```
	function fn(){
		var a=b=c=1; // b和c是隐式全局变量
		var d=1;e=1;f=1; // e和f是隐式全局变量（分号相当于换行）
		var g=1,h=1,i=1; // 都是局部的
	}
	```

- <span id="43">**预解析：**</span>
	- js的解析器在页面加载的时候：
		1. 查看语法错误
		2. 变量声明提升和函数整体提升（变量，提升变量名而不提升变量值；用function定义的函数是整体提升）
		3. 函数范围内，照样适用
	```
	var num = 10;
	fun();
	function fun(){
		console.log(num);
		var num = 20;
	}
	
	// undefined
	```
	
	- 变量的获取和使用符合就近原则

- <span id="44">**函数 function**</span>
	- 函数也是一个对象
	- 函数中可以封装一些功能（代码），在需要时可以执行这些功能（代码）
	- 函数中可以保存一些代码在需要的时候调用
	- 使用typeof检查一个函数对象时，会返回**function**

- **函数的3种定义方式：**
	- 函数声明: `function fn1(){}`
	
	- 函数表达式，即匿名函数: `var fn2 = function(){};`
	
	- 构造函数: `var fn3 = new Function();`
	
	第一种定义方法最强大，在哪里定义完都可以直接使用，后两种要先定义，后面再使用

- <span id="45">**声明提前**</span>
	- 变量的声明提前
		- 使用var关键字声明的变量，会在所有的代码执行之前被声明（但是不会赋值）
		- 但是如果声明变量时不使用var关键字，则变量不会被声明提前
		
	- 函数的声明提前
		- 使用**函数声明形式**创建的函数 function 函数(){}
		- 它会在所有的代码执行之前就被创建，所以我们可以在函数声明前来调用函数
		- 使用函数表达式创建的函数，**不会**被声明提前，所以不能在声明前调用	

- <span id="46">**匿名函数用法：**</span>
	1. `(function(){...})();`
	2. `document.onclick = function(){...}`
	3. `setInterval(function(){...}, 1000);`


- <span id="47">**函数的调用**</span>
	- **call()和apply()**
		- 这两个方法都是函数对象的方法, 需要通过函数对象来调用
		- 当对函数调用call()和apply(), 都会调用函数执行
		- 在调用call()和apply()时, 可以将一个对象指定为第一个参数, 此时这个对象将会成为函数执行时的this
		- call()方法可以将实参在对象之后**依次传递**
		- apply()方法需要将实参封装到一个**数组中统一传递**
		
	- **调用函数时解析器不会检查实参的类型**
		- 所以要注意，是否有可能会接收到非法的参数，如果有可能则需要对参数进行类型的检查
		- 函数的实参可以是任意的数据类型
	- **调用函数时，解析器也不会检查实参的数量**
		- 多余实参不会被赋值
		- 如果实参的数量少于形参的数量，则没有对应实参的形参将是undefined

	- 如果函数return语句后不跟任何值就相当于返回一个undefined，如果函数中不写return，则也会返回undefined

- **在调用函数时，浏览器每次都会传递进两个隐含的参数**: 
	1. 函数的上下文对象 **this**
		- this指向的是一个对象，这个对象我们称为函数执行的 **上下文对象**
		- 根据函数的调用方式的不同，this会指向不同的对象
			1. 以函数的形式调用时，this永远都是window
			2. 以方法的形式调用时，this就是调用方法的那个对象 
			3. 当以构造函数的形式调用时，this就是新创建的那个对象 
			4. 使用call和apply调用时，this是指定的那个对象 

	2. 封装实参的对象 **arguments**
		- arguments是一个**类数组对象**, 它也可以通过索引来操作数据，也可以获取长度
		- 在调用函数时，我们所传递的实参都会在arguments中保存
		- arguments只在函数中使用，是一个伪数组，不能修改长短，不能添加删除元素，但是可以修改元素
		- arguments.length可以用来获取实参的长度
		- 我们即使不定义形参，也可以通过arguments来使用实参，只不过比较麻烦
			- arguments[0] 表示第一个实参
			- arguments[1] 表示第二个实参 
		- 它里边有一个属性叫做callee，这个属性对应一个函数对象，就是当前正在指向的函数的对象
			- `console.log(arguments.callee)`  打印指向的函数对象


- <span id="48">**作用域(Scope)**</span>
	- 作用域指一个变量的作用的范围
	- 在JS中一共有两种作用域：
		1. 全局作用域
			- 直接编写在script标签中的JS代码，都在全局作用域
			- 全局作用域在页面打开时创建，在页面关闭时销毁
			- 在全局作用域中有一个**全局对象window**，它代表的是一个浏览器的窗口，它由浏览器创建我们可以直接使用
			- 在**全局作用域**中：
				- 创建的变量都会作为window对象的属性保存
				- 创建的函数都会作为window对象的方法保存
				- 全局作用域中的变量都是全局变量，在页面的任意的部分都可以访问的到
		2. 函数作用域
			- 调用函数时创建函数作用域，函数执行完毕以后，函数作用域销毁
			- 每调用一次函数就会创建一个新的函数作用域，他们之间是互相独立的
			- 在函数作用域中可以访问到全局作用域的变量，但在全局作用域中无法访问到函数作用域的变量
			- 当在函数作用域操作一个变量时，它会先在自身作用域中寻找，如果有就直接使用
			- 如果没有则向上一级作用域中寻找，直到找到全局作用域，
			- 如果全局作用域中依然没有找到，则会报错ReferenceError
			- 在函数中要访问全局变量可以使用window对象


- <span id="49">**对象属于一种复合的数据类型**</span>
	- 在对象中可以保存多个不同数据类型的属性, 对象的分类：
		1. 内建对象
			- 由ES标准中定义的对象，在任何的ES的实现中都可以使用
			- 比如：Math String Number Boolean Function Object....
		
		2. 宿主对象
			- 由JS的运行环境提供的对象，目前来讲主要指由浏览器提供的对象
			- 比如 BOM DOM
		 
		3. 自定义对象
			- 由开发人员自己创建的对象

	- 向对象添加属性
		- 语法：对象.属性名 = 属性值;
	- 读取对象中的属性
		- 语法：对象.属性名
		- 如果读取对象中没有的属性，不会报错而是会返回undefined，这点和变量不同，当沿着作用域往上，找不到变量时，会报错
	- 修改对象的属性值
		- 语法：对象.属性名 = 新值
	- 删除对象的属性
		- 语法：delete 对象.属性名


- **如果要使用特殊的属性名，不能采用.的方式来操作**
	- 需要使用另一种方式：
	- 语法：对象["属性名"] = 属性值
	- 读取时也需要采用这种方式
		- obj["123"] = 789;
		- obj["nihao"] = "你好";
	
	- 使用[ ]这种形式去操作属性，更加的灵活
	- 在[ ]中可以直接传递一个**变量**，这样变量值是多少就会读取那个属性

- **in 运算符**
	- 通过该运算符可以检查一个对象中是否含有指定的属性，如果有则返回true，没有则返回false
	- 语法："属性名" in 对象
	- 记住属性名要加引号
	- 使用in检查对象中是否含有某个属性时，如果对象中没有但是原型中有，也会返回true

- **枚举对象中的属性**
	- 使用for ... in 语句
	- 语法：
		```
		for(var 变量 in 对象){
		
		}
		```
	- for...in语句, 对象中有几个属性，循环体就会执行几次, 每次执行时，会将对象中的一个属性的名字赋值给变量

- <span id="410">**对象字面量**</span>
	- 使用对象字面量，可以在创建对象时，直接指定对象中的属性
	- 语法：{属性名:属性值,属性名:属性值....}
	- 对象字面量的属性名可以加引号也可以不加，建议不加
	- 如果要使用一些特殊的名字，则必须加引号
	- 注意：
		- 属性名和属性值是一组一组的名值对结构，
		- 名和值之间使用 : 连接，多个名值对之间使用 , 隔开
		- 如果一个属性之后没有其他的属性了，就不要写逗号


- **使用工厂方法创建对象**
	- 通过该方法可以大批量的创建对象

	```		
	function createPerson(name , age ,gender){
		//创建一个新的对象 
		var obj = new Object();
		//向对象中添加属性
		obj.name = name;
		obj.age = age;
		obj.gender = gender;
		obj.sayName = function(){
			alert(this.name);
		};
		//将新的对象返回
		return obj;
	}
	```
	- 使用工厂方法创建的对象，使用的构造函数都是Object, 所以创建的对象都是Object这个类型, 这就导致我们无法区分出多种不同类型的对象


- <span id="411">**构造函数**</span>
	- 使用new关键字调用的函数，是构造函数constructor
	- 构造函数是专门用来创建对象的函数, 它与一般的函数区别是用new来调用
	- `var obj = new Object();`
	- 可以将要封装的代码以字符串的形式传递给构造函数
	
		`var fun = new Function("console.log('Hello 这是我的第一个函数');");`


	- **构造函数的执行流程**:（用关键字new调用的函数）
		1. 立刻创建一个新的对象
		2. 将新建的对象设置为函数中this,在构造函数中可以使用this来引用新建的对象
		3. 逐行执行构造函数中的代码
		4. 将新建的对象作为返回值返回
	
	- **使用同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个类**
		- 我们把通过一个构造函数创建的对象，称为是该类的实例
		- 使用instanceof可以检查一个对象是否是一个类的实例
		- 语法: 对象 instanceof 构造函数
		- 所有的对象都是Object的后代，所以任何对象和Object做instanceof检查时都会返回true

- <span id="412">**原型 prototype**</span>
	
	- 我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype
	- 这个属性对应着一个对象，这个对象就是我们所谓的**原型对象**
	- 如果函数作为普通函数调用, prototype没有任何作用
	- 当函数以构造函数的形式调用时，它所创建的对象中都会有一个隐含的属性，指向该构造函数的原型对象，我们可以通过 \_\_proto\_\_ 来访问该属性
		- 原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象, 我们可以将对象中共有的内容，统一设置到原型对象中。
			
		- 当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用，如果没有则会去原型对象中寻找，如果找到则直接使用
		
		- 以后我们创建构造函数时，可以将这些对象共有的属性和方法，统一添加到构造函数的原型对象中，这样不用分别为每一个对象添加，也不会影响到全局作用域，就可以使每个对象都具有这些属性和方法了
	- `console.log(mc.__proto__ == MyClass.prototype); // true`
	- 使用in检查对象中是否含有某个属性时，如果对象中没有但是原型中有，也会返回true
	- 可以使用对象的hasOwnProperty()来检查对象自身中是否含有该属性, 使用该方法只有当对象自身中含有属性时，才会返回true

- **原型对象也是对象，所以它也有原型**
	- 当我们使用一个对象的属性或方法时，会先在自身中寻找，自身中如果有，则直接使用，如果没有则去原型对象中寻找，如果原型对象中没有，则继续往上
	- 直到找到Object对象的原型
	- Object对象的原型没有原型，如果在Object原型中依然没有找到，则返回undefined			
	- `console.log(mc.__proto__.__proto__.__proto__) // null`	object对象的原型没有原型

- **对象的toString**

	- 当我们直接在页面中打印一个对象时, 实际上是输出对象的toString()方法的返回值, 
	- 如果我们希望在输出对象时不输出[object Object]，可以为对象添加一个toString()方法
	- 修改Person原型的toString
	
		```
		Person.prototype.toString = function(){
			return "Person[name="+this.name+",age="+this.age+",gender="+this.gender+"]";
		};
		```
- **通过对象字面量重写原型对象**
	- 很多时候，为了书写的方便以及直观上的“封装性”，往往采用对象字面量直接重写整个原型对象
		
		```
		function Student(){
			Student.prototype = {
				constructor : Student, //constructor属性也是一个指针，指向prototype所在的函数
				name : "easy",
				age : 20,
				alertName : function(){alert(this.name);}
			};
		}
		```
	- 这里相当于用对象字面量重新创建了一个Object对象，然后使Student的prototype指针指向该对象，

	- 该对象在创建的过程中，自动获得了新的constructor属性，该属性指向Object的构造函数，因此需要显式指定constructor属性为Student，使其重新指向Student构造函数

	- 在构造函数中定义实例属性，在原型中定义共享属性的模式，是目前引用最广泛的方式，通常使用这种方式来定义引用类型变量	

- **JS中的包装类**

	在JS中为我们提供了三个**包装类**，通过这三个包装类可以将基本数据类型的数据转换为对象
	- String(), 可以将基本数据类型字符串转换为String对象
	- Number(), 可以将基本数据类型的数字转换为Number对象
	- Boolean(), 可以将基本数据类型的布尔值转换为Boolean对象
	- 但是注意：我们在实际应用中**不会使用**基本数据类型的对象，如果使用基本数据类型的对象，在做一些比较时可能会带来一些不可预期的结果			
	
		- 浏览器底层自己用包装类，我们一般不用
		- 方法和属性只能添加给对象，不能添加给基本数据类型
		- 当我们对一些基本数据类型的值去调用属性和方法时，浏览器会临时使用包装类将其转换为对象，然后在调用对象的属性和方法, 调用完以后, 再将其转换为基本数据类型	
		
		```
		var b = new Boolean(false);			
		if(b){
			alert("我运行了~~~"); //运行
		}
		```	

